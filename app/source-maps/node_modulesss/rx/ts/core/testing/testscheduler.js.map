{"version":3,"sources":["node_modulesss/rx/ts/core/testing/testscheduler.ts"],"names":[],"mappings":"AAAA,+DAA+D;AAC/D,yCAAyC;AACzC,sCAAsC;AACtC,0CAA0C;AAC1C,IAAO,EAAE,CAmER;AAnED,WAAO,EAAE;AAmET,CAAC,EAnEM,EAAE,KAAF,EAAE,QAmER;AAED,CAAC;IACG,IAAI,EAAE,GAAsB,IAAI,EAAE,CAAC,aAAa,EAAE,CAAC;IAEnD,IAAI,CAAC,GAA2B,EAAE,CAAC,oBAAoB,CAAS,IAAI,EAAE,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IAC3F,IAAI,CAAC,GAA2B,EAAE,CAAC,mBAAmB,CAAS,IAAI,EAAE,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IAC1F,IAAI,EAAE,GAA8B,EAAE,CAAC,cAAc,EAAW,CAAC;IAEjE,IAAI,CAAC,GAAyB,EAAE,CAAC,qBAAqB,CAAU,GAAG,EAAE,KAAK,CAAC,CAAC;IAC5E,IAAI,CAAC,GAAyB,EAAE,CAAC,qBAAqB,CAAU,GAAG,EAAE,KAAK,CAAC,CAAC;IAE5E,IAAI,EAAE,GAAG,EAAE,CAAC,eAAe,CAAU,cAAM,OAAA,EAAE,CAAC,UAAU,CAAC,MAAM,CAAe,IAAI,CAAC,EAAxC,CAAwC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IACpG,IAAI,EAAE,GAAG,EAAE,CAAC,gBAAgB,CAAU,cAAM,OAAA,EAAE,CAAC,UAAU,CAAC,MAAM,CAAe,IAAI,CAAC,EAAxC,CAAwC,EAAE,GAAG,CAAC,CAAC;IAC3F,IAAI,EAAE,GAAG,EAAE,CAAC,eAAe,CAAU,cAAM,OAAA,EAAE,CAAC,UAAU,CAAC,MAAM,CAAe,IAAI,CAAC,EAAxC,CAAwC,CAAC,CAAC;AACzF,CAAC,CAAC,CAAC","file":"node_modulesss/rx/ts/core/testing/testscheduler.js","sourcesContent":["/// <reference path=\"../concurrency/virtualtimescheduler.ts\" />\n/// <reference path=\"../observable.ts\" />\n/// <reference path=\"./recorded.ts\" />\n/// <reference path=\"./mockobserver.ts\" />\nmodule Rx {\n\n    export interface TestScheduler extends VirtualTimeScheduler<number, number> {\n        /**\n         * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.\n         * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.\n         * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.\n         */\n        createColdObservable<T>(...records: Recorded[]): Observable<T>;\n        /**\n         * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.\n         * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.\n         * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.\n         */\n        createHotObservable<T>(...records: Recorded[]): Observable<T>;\n        /**\n         * Creates an observer that records received notification messages and timestamps those.\n         * @return Observer that can be used to assert the timing of received notifications.\n         */\n        createObserver<T>(): MockObserver<T>;\n\n        /**\n         * Creates a resolved promise with the given value and ticks\n         * @param {Number} ticks The absolute time of the resolution.\n         * @param {Any} value The value to yield at the given tick.\n         * @returns {MockPromise} A mock Promise which fulfills with the given value.\n         */\n        createResolvedPromise<T>(ticks: number, value: T): IPromise<T>;\n        /**\n         * Creates a rejected promise with the given reason and ticks\n         * @param {Number} ticks The absolute time of the resolution.\n         * @param {Any} reason The reason for rejection to yield at the given tick.\n         * @returns {MockPromise} A mock Promise which rejects with the given reason.\n         */\n        createRejectedPromise<T>(ticks: number, value: T): IPromise<T>;\n\n        /**\n         * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.\n         *\n         * @param create Factory method to create an observable sequence.\n         * @param created Virtual time at which to invoke the factory to create an observable sequence.\n         * @param subscribed Virtual time at which to subscribe to the created observable sequence.\n         * @param disposed Virtual time at which to dispose the subscription.\n         * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.\n         */\n        startWithTiming<T>(create: () => Observable<T>, createdAt: number, subscribedAt: number, disposedAt: number): MockObserver<T>;\n        /**\n         * Starts the test scheduler and uses the specified virtual time to dispose the subscription to the sequence obtained through the factory function.\n         * Default virtual times are used for factory invocation and sequence subscription.\n         *\n         * @param create Factory method to create an observable sequence.\n         * @param disposed Virtual time at which to dispose the subscription.\n         * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.\n         */\n        startWithDispose<T>(create: () => Observable<T>, disposedAt: number): MockObserver<T>;\n        /**\n         * Starts the test scheduler and uses default virtual times to invoke the factory function, to subscribe to the resulting sequence, and to dispose the subscription.\n         *\n         * @param create Factory method to create an observable sequence.\n         * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.\n         */\n        startWithCreate<T>(create: () => Observable<T>): MockObserver<T>;\n    }\n\n    export var TestScheduler: {\n        new (): TestScheduler;\n    }\n}\n\n(function() {\n    var ts : Rx.TestScheduler = new Rx.TestScheduler();\n\n    var o : Rx.Observable<string> = ts.createColdObservable<string>(new Rx.Recorded(100, '5'));\n    var o : Rx.Observable<string> = ts.createHotObservable<string>(new Rx.Recorded(100, '5'));\n    var ob : Rx.MockObserver<boolean> = ts.createObserver<boolean>();\n\n    var p : Rx.Promise<boolean> = ts.createResolvedPromise<boolean>(100, false);\n    var p : Rx.Promise<boolean> = ts.createRejectedPromise<boolean>(100, false);\n\n    var ob = ts.startWithTiming<boolean>(() => Rx.Observable.create<boolean>(<any>null), 100, 200, 300);\n    var ob = ts.startWithDispose<boolean>(() => Rx.Observable.create<boolean>(<any>null), 300);\n    var ob = ts.startWithCreate<boolean>(() => Rx.Observable.create<boolean>(<any>null));\n});\n"],"sourceRoot":"/source/"}