{"version":3,"sources":["node_modulesss/rx/ts/core/linq/observable/groupbyuntil.ts"],"names":[],"mappings":"AAAA,4CAA4C;AAC5C,gDAAgD","file":"node_modulesss/rx/ts/core/linq/observable/groupbyuntil.js","sourcesContent":["/// <reference path=\"../../observable.ts\" />\n/// <reference path=\"../groupedobservable.ts\" />\nmodule Rx {\n    export interface Observable<T> {\n        /**\n        *  Groups the elements of an observable sequence according to a specified key selector function.\n        *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n        *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n        *\n        * @example\n        *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n        *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n        *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n        * @param {Function} keySelector A function to extract the key for each element.\n        * @param {Function} durationSelector A function to signal the expiration of a group.\n        * @returns {Observable}\n        *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n        *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n        *\n        */\n        groupByUntil<TKey, TDuration>(keySelector: (value: T) => TKey, skipElementSelector: boolean, durationSelector: (group: GroupedObservable<TKey, T>) => Observable<TDuration>, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, T>>;\n\n        /**\n        *  Groups the elements of an observable sequence according to a specified key selector function.\n        *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n        *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n        *\n        * @example\n        *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n        *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n        *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n        * @param {Function} keySelector A function to extract the key for each element.\n        * @param {Function} durationSelector A function to signal the expiration of a group.\n        * @returns {Observable}\n        *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n        *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n        *\n        */\n        groupByUntil<TKey, TElement, TDuration>(keySelector: (value: T) => TKey, elementSelector: (value: T) => TElement, durationSelector: (group: GroupedObservable<TKey, TElement>) => Observable<TDuration>, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, TElement>>;\n    }\n}\n"],"sourceRoot":"/source/"}