{"version":3,"sources":["node_modulesss/rx/ts/core/linq/observable/generate.ts"],"names":[],"mappings":"AAAA,4CAA4C;AAC5C,uDAAuD","file":"node_modulesss/rx/ts/core/linq/observable/generate.js","sourcesContent":["/// <reference path=\"../../observable.ts\" />\n/// <reference path=\"../../concurrency/scheduler.ts\" />\nmodule Rx {\n    export interface ObservableStatic {\n        /**\n         *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.\n         *\n         * @example\n         *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });\n         *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);\n         * @param {Mixed} initialState Initial state.\n         * @param {Function} condition Condition to terminate generation (upon returning false).\n         * @param {Function} iterate Iteration step function.\n         * @param {Function} resultSelector Selector function for results produced in the sequence.\n         * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.\n         * @returns {Observable} The generated sequence.\n         */\n        generate<TState, TResult>(initialState: TState, condition: (state: TState) => boolean, iterate: (state: TState) => TState, resultSelector: (state: TState) => TResult, scheduler?: IScheduler): Observable<TResult>;\n    }\n}\n"],"sourceRoot":"/source/"}