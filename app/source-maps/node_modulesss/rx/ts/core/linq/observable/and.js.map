{"version":3,"sources":["node_modulesss/rx/ts/core/linq/observable/and.ts"],"names":[],"mappings":"AAAA,4CAA4C;AAC5C,+CAA+C;AAa/C,CAAC;IACG,IAAI,CAAwB,CAAC;IAE7B,IAAI,CAAmB,CAAC;IAGxB,IAAI,CAAmB,CAAC;IAGxB,IAAI,CAAmB,CAAC;IAExB,IAAI,CAAC,GAA0B,EAAE,CAAC,UAAU,CAAC,IAAI,CAC7C,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;QACrC,MAAM,CAAC,GAAG,CAAC;IACf,CAAC,CAAC,CACL,CAAC;AACN,CAAC,CAAC,CAAC","file":"node_modulesss/rx/ts/core/linq/observable/and.js","sourcesContent":["/// <reference path=\"../../observable.ts\" />\n/// <reference path=\"../../joins/pattern.ts\" />\nmodule Rx {\n    export interface Observable<T> {\n        /**\n        *  Creates a pattern that matches when both observable sequences have an available value.\n        *\n        *  @param right Observable sequence to match with the current sequence.\n        *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.\n        */\n        and<T2>(right: Observable<T2>): Pattern2<T, T2>;\n    }\n}\n\n(function() {\n    var r: Rx.Observable<string>;\n    interface A { }\n    var a: Rx.Observable<A>;\n\n    interface B { }\n    var b: Rx.Observable<B>;\n\n    interface C { }\n    var c: Rx.Observable<C>;\n\n    var n: Rx.Observable<number> = Rx.Observable.when(\n        r.and(a).and(b).and(c).thenDo((r, a, b, c) => {\n            return 123;\n        })\n    );\n});\n"],"sourceRoot":"/source/"}