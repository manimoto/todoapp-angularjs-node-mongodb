{"version":3,"sources":["node_modulesss/rx/ts/core/linq/observable/bufferwithtimeorcount.ts"],"names":[],"mappings":"AAAA,4CAA4C;AAC5C,uDAAuD;AAcvD,CAAC;IACG,IAAI,CAAwB,CAAC;IAC7B,IAAI,EAAE,GAA4B,CAAC,CAAC,qBAAqB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACpE,IAAI,EAAE,GAA4B,CAAC,CAAC,qBAAqB,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AAC9F,CAAC,CAAC,CAAA","file":"node_modulesss/rx/ts/core/linq/observable/bufferwithtimeorcount.js","sourcesContent":["/// <reference path=\"../../observable.ts\" />\n/// <reference path=\"../../concurrency/scheduler.ts\" />\nmodule Rx {\n    export interface Observable<T> {\n        /**\n        *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.\n        * @param {Number} timeSpan Maximum time length of a buffer.\n        * @param {Number} count Maximum element count of a buffer.\n        * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.\n        * @returns {Observable} An observable sequence of buffers.\n        */\n        bufferWithTimeOrCount(timeSpan: number, count: number, scheduler?: IScheduler): Observable<T[]>;\n    }\n}\n\n(function() {\n    var o: Rx.Observable<string>;\n    var so: Rx.Observable<string[]> = o.bufferWithTimeOrCount(100, 200);\n    var so: Rx.Observable<string[]> = o.bufferWithTimeOrCount(100, 200, Rx.Scheduler.default);\n})\n"],"sourceRoot":"/source/"}