{"version":3,"sources":["node_moduless/rx/ts/core/observer-extras.ts"],"names":[],"mappings":"AAAA,oDAAoD;AACpD,6CAA6C;AAC7C,0CAA0C;AA4C1C,CAAC;IACG,IAAI,QAA8B,CAAC;IACnC,IAAI,CAAC,GAAqD,QAAQ,CAAC,UAAU,EAAE,CAAC;IAEhF,IAAI,CAAC,GAAyB,QAAQ,CAAC,UAAU,EAAE,CAAC;IAEpD,IAAI,CAAC,GAAgC,QAAQ,CAAC,OAAO,EAAE,CAAC;IAExD,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAE9C,IAAI,EAAE,GAAyB,EAAE,CAAC,QAAQ,CAAC,YAAY,CAAS,UAAC,CAAC;QAC9D,oBAAoB;QACpB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;YACjB,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;QAED,qBAAqB;QACrB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;YACjB,OAAO,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC;QACzC,CAAC;QAED,mBAAmB;QACnB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;YACjB,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAA;QAC5B,CAAC;IACL,CAAC,CAAC,CAAC;AACP,CAAC,CAAC,CAAC","file":"node_moduless/rx/ts/core/observer-extras.js","sourcesContent":["/// <reference path=\"./disposables/disposable.ts\" />\n/// <reference path=\"./checkedobserver.ts\" />\n/// <reference path=\"./notification.ts\" />\nmodule Rx {\n\texport interface Observer<T> {\n        /**\n        *  Creates a notification callback from an observer.\n        * @returns The action that forwards its input notification to the underlying observer.\n        */\n\t\ttoNotifier(): (notification: Notification<T>) => void;\n\n        /**\n        *  Hides the identity of an observer.\n        * @returns An observer that hides the identity of the specified observer.\n        */\n\t\tasObserver(): Observer<T>;\n\n        /**\n        *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.\n        *  If a violation is detected, an Error is thrown from the offending observer method call.\n        * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.\n        */\n        checked(): CheckedObserver<T>;\n\n        /**\n        * Schedules the invocation of observer methods on the given scheduler.\n        * @param {Scheduler} scheduler Scheduler to schedule observer messages on.\n        * @returns {Observer} Observer whose messages are scheduled on the given scheduler.\n        */\n        notifyOn(scheduler: IScheduler): Observer<T>;\n\t}\n\n\texport interface ObserverStatic {\n        /**\n        *  Creates an observer from a notification callback.\n        *\n        * @static\n        * @memberOf Observer\n        * @param {Function} handler Action that handles a notification.\n        * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.\n        */\n\t\tfromNotifier<T>(handler: (notification: Notification<T>, thisArg?: any) => void): Observer<T>;\n\t}\n}\n\n\n(function() {\n    var observer: Rx.Observer<boolean>;\n    var n: (notification: Rx.Notification<boolean>) => void = observer.toNotifier();\n\n    var o: Rx.Observer<boolean> = observer.asObserver();\n\n    var c: Rx.CheckedObserver<boolean> = observer.checked();\n\n    o = observer.notifyOn(Rx.Scheduler.immediate);\n\n    var so : Rx.Observer<number> = Rx.Observer.fromNotifier<number>((n) => {\n        // Handle next calls\n        if (n.kind === 'N') {\n            console.log('Next: ' + n.value);\n        }\n\n        // Handle error calls\n        if (n.kind === 'E') {\n            console.log('Error: ' + n.exception);\n        }\n\n        // Handle completed\n        if (n.kind === 'C') {\n            console.log('Completed')\n        }\n    });\n});\n"],"sourceRoot":"/source/"}