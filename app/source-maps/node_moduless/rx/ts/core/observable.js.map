{"version":3,"sources":["node_moduless/rx/ts/core/observable.ts"],"names":[],"mappings":"AAAA,iCAAiC;AACjC,oDAAoD;AACpD,2CAA2C;AAC3C,IAAO,EAAE,CAsHR;AAtHD,WAAO,EAAE;IACL,IAAc,MAAM,CAEnB;IAFD,WAAc,MAAM;IAEpB,CAAC,EAFa,MAAM,GAAN,SAAM,KAAN,SAAM,QAEnB;IAED,IAAc,OAAO,CAapB;IAbD,WAAc,OAAO;IAarB,CAAC,EAba,OAAO,GAAP,UAAO,KAAP,UAAO,QAapB;AAoGL,CAAC,EAtHM,EAAE,KAAF,EAAE,QAsHR;AAGD,CAAC;IACG,IAAI,QAA8B,CAAC;IACnC,IAAI,UAAiC,CAAC;IAEtC,UAAU,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;IAC/B,UAAU,CAAC,SAAS,CAAC,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IAChC,UAAU,CAAC,SAAS,CAAC,UAAC,CAAC,IAAM,CAAC,EAAE,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IAC3C,UAAU,CAAC,SAAS,CAAC,UAAC,CAAC,IAAM,CAAC,EAAE,UAAC,CAAC,IAAM,CAAC,EAAE,cAAO,CAAC,CAAC,CAAC;IAErD,UAAU,CAAC,eAAe,CAAC,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IACtC,UAAU,CAAC,eAAe,CAAC,UAAC,CAAC,IAAM,CAAC,EAAE,EAAE,CAAC,CAAC;IAE1C,UAAU,CAAC,gBAAgB,CAAC,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IACvC,UAAU,CAAC,gBAAgB,CAAC,UAAC,CAAC,IAAM,CAAC,EAAE,EAAE,CAAC,CAAC;IAE3C,UAAU,CAAC,oBAAoB,CAAC,cAAO,CAAC,CAAC,CAAC;IAC1C,UAAU,CAAC,oBAAoB,CAAC,cAAO,CAAC,EAAE,EAAE,CAAC,CAAC;IAE9C,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC7B,UAAU,CAAC,OAAO,CAAC,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IAC9B,UAAU,CAAC,OAAO,CAAC,UAAC,CAAC,IAAM,CAAC,EAAE,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IACzC,UAAU,CAAC,OAAO,CAAC,UAAC,CAAC,IAAM,CAAC,EAAE,UAAC,CAAC,IAAM,CAAC,EAAE,cAAO,CAAC,CAAC,CAAC;IAEnD,EAAE,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC","file":"node_moduless/rx/ts/core/observable.js","sourcesContent":["/// <reference path=\"./es6.ts\" />\n/// <reference path=\"./disposables/disposable.ts\" />\n/// <reference path=\"./observer-lite.ts\" />\nmodule Rx {\n    export module config {\n        export var Promise: { new <T>(resolver: (resolvePromise: (value: T) => void, rejectPromise: (reason: any) => void) => void): IPromise<T>; };\n    }\n\n    export module helpers {\n        export var noop: () => void;\n        export var notDefined: (value: any) => boolean;\n        export var identity: <T>(value: T) => T;\n        export var defaultNow: () => number;\n        export var defaultComparer: (left: any, right: any) =>  boolean;\n        export var defaultSubComparer: (left: any, right: any) =>  number;\n        export var defaultKeySerializer: (key: any) =>  string;\n        export var defaultError: (err: any) =>  void;\n        export var isPromise: (p: any) =>  boolean;\n        export var asArray: <T>(...args: T[]) =>  T[];\n        export var not: (value: any) =>  boolean;\n        export var isFunction: (value: any) =>  boolean;\n    }\n\n    export type _Selector<T, TResult> = (value: T, index: number, observable: Observable<T>) => TResult;\n    export type _ValueOrSelector<T, TResult> = TResult | _Selector<T, TResult>;\n    export type _Predicate<T> = _Selector<T, boolean>;\n    export type _Comparer<T, TResult> = (value1: T, value2: T) => TResult;\n    export type _Accumulator<T, TAcc> = (acc: TAcc, value: T) => TAcc;\n\n    export module special {\n        export type _FlatMapResultSelector<T1, T2, TResult> = (value: T1, selectorValue: T2, index: number, selectorOther: number) => TResult;\n    }\n\n    export interface IObservable<T> {\n        /**\n        *  Subscribes an o to the observable sequence.\n        *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n        *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n        *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n        *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribe(observer: IObserver<T>): IDisposable;\n        /**\n        *  Subscribes an o to the observable sequence.\n        *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n        *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n        *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n        *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribe(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): IDisposable;\n    }\n\n    export interface Observable<T> {\n        /**\n        *  Subscribes an o to the observable sequence.\n        *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n        *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n        *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n        *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribe(observer: IObserver<T>): IDisposable;\n        /**\n        *  Subscribes an o to the observable sequence.\n        *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n        *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n        *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n        *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribe(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): IDisposable;\n\n        /**\n        * Subscribes to the next value in the sequence with an optional \"this\" argument.\n        * @param {Function} onNext The function to invoke on each element in the observable sequence.\n        * @param {Any} [thisArg] Object to use as this when executing callback.\n        * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribeOnNext(onNext: (value: T) => void, thisArg?: any): IDisposable;\n        /**\n        * Subscribes to an exceptional condition in the sequence with an optional \"this\" argument.\n        * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.\n        * @param {Any} [thisArg] Object to use as this when executing callback.\n        * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribeOnError(onError: (exception: any) => void, thisArg?: any): IDisposable;\n        /**\n        * Subscribes to the next value in the sequence with an optional \"this\" argument.\n        * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.\n        * @param {Any} [thisArg] Object to use as this when executing callback.\n        * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        subscribeOnCompleted(onCompleted: () => void, thisArg?: any): IDisposable;\n\n        /**\n        *  Subscribes an o to the observable sequence.\n        *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n        *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n        *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n        *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        forEach(observer: IObserver<T>): IDisposable;\n\n        /**\n        *  Subscribes an o to the observable sequence.\n        *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n        *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n        *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n        *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n        */\n        forEach(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): IDisposable;\n    }\n\n    export interface ObservableStatic {\n        /**\n        * Determines whether the given object is an Observable\n        * @param {Any} An object to determine whether it is an Observable\n        * @returns {Boolean} true if an Observable, else false.\n        */\n        isObservable(o: any): boolean;\n    }\n\n    export var Observable: ObservableStatic;\n}\n\n\n(function() {\n    var observer: Rx.IObserver<number>;\n    var observable: Rx.Observable<number>;\n\n    observable.subscribe(observer);\n    observable.subscribe((v) => {});\n    observable.subscribe((v) => {}, (e) => {});\n    observable.subscribe((v) => {}, (e) => {}, () => {});\n\n    observable.subscribeOnNext((v) => {});\n    observable.subscribeOnNext((v) => {}, {});\n\n    observable.subscribeOnError((v) => {});\n    observable.subscribeOnError((v) => {}, {});\n\n    observable.subscribeOnCompleted(() => {});\n    observable.subscribeOnCompleted(() => {}, {});\n\n    observable.forEach(observer);\n    observable.forEach((v) => {});\n    observable.forEach((v) => {}, (e) => {});\n    observable.forEach((v) => {}, (e) => {}, () => {});\n\n    Rx.Observable.isObservable({});\n});\n"],"sourceRoot":"/source/"}